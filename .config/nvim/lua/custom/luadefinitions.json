{
  "lua_newstate": "Creates a new, independent Lua state. Returns a pointer to the new state, or NULL if memory cannot be allocated.",
  "lua_close": "Destroys all objects in the given Lua state and releases all dynamic memory used by it.",
  "luaL_newstate": "Creates a new Lua state with a minimal stack and calls lua_atpanic to set a new panic function that prints an error message on stderr when a fatal error occurs.",
  "luaL_openlibs": "Opens all standard Lua libraries into the given state.",
  "lua_getglobal": "Pushes onto the stack the value of the global name.",
  "lua_setglobal": "Pops a value from the stack and sets it as the new value of the global name.",
  "lua_pushnil": "Pushes a nil value onto the stack.",
  "lua_pushboolean": "Pushes a boolean value onto the stack.",
  "lua_pushnumber": "Pushes a floating-point number onto the stack.",
  "lua_pushinteger": "Pushes an integer onto the stack.",
  "lua_pushlstring": "Pushes the string pointed to by s with size len onto the stack. Lua makes (or reuses) an internal copy of the given string.",
  "lua_pushstring": "Pushes the zero-terminated string pointed to by s onto the stack. Lua makes (or reuses) an internal copy of the given string.",
  "lua_pushcclosure": "Pushes a new C closure onto the stack. When it is called, the C function f is executed with upvalues uvn being accessible.",
  "lua_pushcfunction": "Pushes a C function onto the stack. This function receives a pointer to a C function and pushes onto the stack a Lua value of type function that, when called, executes the corresponding C function.",
  "lua_callk": "Calls a function. It follows exactly the same protocol as lua_call but also allows the called function to yield.",
  "lua_call": "Calls a function. To do this, you must first push the function to be called and then push its arguments in direct order; that is, the first argument is pushed first. When you call the function, you pop all arguments and the function value from the stack, and you push the results of the call.",
  "lua_pcallk": "Calls a function in protected mode. Both narg and nres have the same meaning as in lua_callk.",
  "lua_pcall": "Calls a function in protected mode. Both narg and nres have the same meaning as in lua_call.",
  "lua_gettop": "Returns the index of the top element of the stack. Because indices start at 1, this result is also equal to the number of elements in the stack; in particular, 0 means an empty stack.",
  "lua_settop": "Accepts any acceptable index, or 0, and sets the stack top to this new index. If the new top is larger than the old one, then the new stack slots are filled with nil.",
  "lua_pushvalue": "Pushes a copy of the element at the given acceptable index onto the stack.",
  "lua_remove": "Removes the element at the given valid index, shifting down the elements above it to fill the gap. You cannot call this function with pseudo-indices.",
  "lua_insert": "Moves the top element into the given valid index without shifting any element (therefore replacing the value at that index). You cannot call this function with pseudo-indices.",
  "lua_replace": "Moves the top element into the given index without shifting any element (therefore replacing the value at that index), and then pops the top element.",
  "lua_type": "Returns the type of the value at the given acceptable index.",
  "lua_typename": "Returns the name of the type encoded by the value tp. tp must be one of the values returned by lua_type.",
  "lua_isnil": "Returns 1 if the value at the given acceptable index is nil, and 0 otherwise.",
  "lua_isboolean": "Returns 1 if the value at the given acceptable index is a boolean, and 0 otherwise.",
  "lua_isnumber": "Returns 1 if the value at the given acceptable index is a number (can be integer or float), and 0 otherwise.",
  "lua_isinteger": "Returns 1 if the value at the given acceptable index is an integer, and 0 otherwise.",
  "lua_isstring": "Returns 1 if the value at the given acceptable index is a string or a number (which is always convertible to a string), and 0 otherwise.",
  "lua_iscfunction": "Returns 1 if the value at the given acceptable index is a C function, and 0 otherwise.",
  "lua_isuserdata": "Returns 1 if the value at the given acceptable index is a userdata (either full or light), and 0 otherwise.",
  "lua_istable": "Returns 1 if the value at the given acceptable index is a table, and 0 otherwise.",
  "lua_isthread": "Returns 1 if the value at the given acceptable index is a thread, and 0 otherwise.",
  "lua_toboolean": "Converts the Lua value at the given acceptable index to a C boolean value (0 or 1). Like all tests in Lua, lua_toboolean considers any value different from false and nil as true; otherwise, it considers it false. It also returns false when called with an invalid index.",
  "lua_tonumberx": "Converts the Lua value at the given acceptable index to the C type lua_Number (that is, a double) or to a value of another numeric type if needed. If the Lua value is not convertible to a number, the function returns 0 (zero) plus sets *isnum to LUA_FALSE; otherwise, it returns the converted number plus sets *isnum to LUA_TRUE.",
  "lua_tonumber": "Equivalent to lua_tonumberx with isnum equal to NULL.",
  "lua_tointegerx": "Converts the Lua value at the given acceptable index to the C type lua_Integer (a signed integer type) or to a value of another integer type if needed. If the Lua value is not convertible to an integer, the function returns 0 (zero) plus sets *isnum to LUA_FALSE; otherwise, it returns the converted integer plus sets *isnum to LUA_TRUE.",
  "lua_tointeger": "Equivalent to lua_tointegerx with isnum equal to NULL.",
  "lua_tolstring": "Converts the Lua value at the given acceptable index to a C string. If len is not NULL, it also sets *len with the string length. Lua makes (or reuses) an internal copy of the returned string, so the pointer returned by lua_tolstring may be invalidated if the stack is changed. The Lua value at the given acceptable index must be a string or a number; otherwise, the function returns NULL.",
  "lua_tostring": "Equivalent to lua_tolstring with len equal to NULL.",
  "lua_tocfunction": "Converts a value at the given acceptable index to a C function. That value must be a C function; otherwise, returns NULL.",
  "lua_touserdata": "If the value at the given acceptable index is a full userdata, returns its block address. If the value is a light userdata, it returns its pointer. Otherwise, returns NULL.",
  "lua_tothread": "Converts the value at the given acceptable index to a Lua thread (represented as lua_State*). This value must be a thread; otherwise, the function returns NULL.",
  "lua_topointer": "Converts the value at the given acceptable index to a generic C pointer (void*). The value can be a userdata, a table, a thread, or a function; otherwise, it returns NULL. Different objects of the same type may return different pointers.",
  "lua_createtable": "Creates a new empty table and pushes it onto the stack. It allocates space for narr array elements and nrec non-array elements.",
  "lua_gettable": "Pushes onto the stack the value t[k], where t is the value at the given acceptable index and k is the value at the top of the stack. This function pops the key from the stack (the resulting value is put in its place). As in Lua, this function may trigger a metamethod for the \"index\" event.",
  "lua_settable": "Does the equivalent to t[k] = v, where t is the value at the given acceptable index, v is the value at the top of the stack, and k is the value just below the top. This function pops both the key and the value from the stack. As in Lua, this function may trigger a metamethod for the \"newindex\" event.",
  "lua_getfield": "Pushes onto the stack the value t[k], where t is the value at the given acceptable index and k is the string s.",
  "lua_setfield": "Does the equivalent to t[k] = v, where t is the value at the given acceptable index and v is the value at the top of the stack. This function pops the value from the stack.",
  "lua_rawget": "Similar to lua_gettable, but does a direct access to the table t (without metamethods).",
  "lua_rawgeti": "Pushes onto the stack the value t[n], where t is the value at the given acceptable index and n is an integer.",
  "lua_rawset": "Similar to lua_settable, but does a direct assignment to the table t (without metamethods).",
  "lua_rawseti": "Does the equivalent to t[n] = v, where t is the value at the given acceptable index and v is the value at the top of the stack. This function pops the value from the stack.",
  "lua_next": "Pops a key from the stack, and pushes a key-value pair from the table at the given index (the \"next\" pair after the given key). If there are no more elements in the table, then lua_next returns 0 (and pushes nothing).",
  "lua_concat": "Concatenates the n values at the top of the stack, pops them, and pushes the result. If n is 1, the result is the single value on the stack (that is, the function does nothing); if n is 0, the result is the empty string. Concatenation is performed following the usual semantics of Lua (see ยง3.4.6).",
  "lua_len": "Returns the \"length\" of the value at the given acceptable index. It pushes the result onto the stack. The length of a table t is defined only if the table has a \"__len\" metamethod or if the table has only non-negative integer keys starting at 1 and without gaps.",
  "luaL_ref": "Creates and returns a reference, in the table at index t, for the value at the top of the stack (and pops the value).",
  "luaL_unref": "Releases reference ref from the table at index t (see luaL_ref). The entry is removed from the table so that the referred value can be collected.",
  "luaL_loadstring": "Loads a string as a Lua chunk. This function uses lua_load to load the chunk in the string s with size sz.",
  "luaL_loadfilex": "Loads a file as a Lua chunk. This function uses lua_load to load the chunk in the file named filename.",
  "luaL_dostring": "Loads and runs the given string.",
  "luaL_dofile": "Loads and runs the given file.",
  "luaL_getmetatable": "Pushes onto the stack the metatable associated with the name tname in the registry (see ยง4.5). If there is no metatable associated with that name, pushes nil.",
  "luaL_newmetatable": "Creates a new table to be used as a metatable. It pushes this new table onto the stack and associates it with the name tname in the registry (see ยง4.5). If there is already a table associated with tname, the function simply returns 0 and leaves the current stack unchanged.",
  "luaL_setmetatable": "Sets the metatable of the value at the given acceptable index. It pops a table from the stack and sets it as the new metatable of the value at the given index.",
  "luaL_checkudata": "Checks whether the userdata at the given index is of a specific type (tname). It returns the userdata address (as a void*). If the userdata is not of that type, raises an error.",
  "luaL_checklstring": "Checks whether the function argument arg is a string and returns this string. If l is not NULL fills *l with the string's actual length.",
  "luaL_checkstring": "Checks whether the function argument arg is a string and returns this string.",
  "luaL_checknumber": "Checks whether the function argument arg is a number and returns this number as a lua_Number.",
  "luaL_checkinteger": "Checks whether the function argument arg is an integer and returns this integer as a lua_Integer.",
  "luaL_checkboolean": "Checks whether the function argument arg is a boolean and returns its value as a C integer (1 for true, 0 for false).",
  "luaL_argcheck": "Checks whether cond is true. If not, raises a standard error with a message of the form 'bad argument index to name (expected type, got type)'.",
  "luaL_error": "Raises a Lua error. The error message is the concatenation of fmt and any extra arguments, following the same rules of lua_pushfstring.",
  "luaL_where": "Pushes onto the stack a string identifying the current position of the control at level lev in the call stack. Typically this string has the following format: 'chunkname:currentline:'. Level 0 is the running function, level 1 is the function that called the running function, etc.",
  "lua_yieldk": "Yields a coroutine. This function should only be called as the return expression of a C function.",
  "lua_resume": "Starts or resumes a coroutine.",
  "lua_status": "Returns the status of the thread t. The status can be LUA_OK, LUA_YIELD, LUA_ERRRUN, LUA_ERRSYNTAX, LUA_ERRMEM, LUA_ERRGCMM, and LUA_ERRERR.",
  "lua_getupvalue": "Gets the index i of a closure's upvalue. It pushes onto the stack the value of the upvalue and returns its name.",
  "lua_setupvalue": "Sets the value of a closure's upvalue. It pops a value from the stack and assigns it to the upvalue index i of the function at index funcindex. It returns the name of the upvalue.",
  "lua_upvalueid": "Returns a unique identifier for the upvalue numbered n from the function at index funcindex.",
  "lua_upvaluejoin": "Make the n-th upvalue of the Lua closure at index funcindex1 refer to the n-th upvalue of the Lua closure at index funcindex2."
}
